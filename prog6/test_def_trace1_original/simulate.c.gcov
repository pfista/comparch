        -:    0:Source:simulate.c
        -:    0:Programs:5
        -:    1:
        -:    2:/* ***************************************************************** */
        -:    3:/*                                                                   */
        -:    4:/*                                                                   */
        -:    5:/* ***************************************************************** */
        -:    6:
        -:    7:/* The code to read a memory trace and simulate it on the various
        -:    8:   caches. */
        -:    9:
        -:   10:#include "global.h"
        -:   11:#include "utils.h"        // utility functions
        -:   12:#include "cds.h"          // Cache Description Structures
        -:   13:#include "caches.h"       // cache manipulation code
        -:   14:
        -:   15:
        -:   16:struct memory_reference
        -:   17:{
        -:   18:    enum memory_access_type  type;
        -:   19:    memory_address           address;
        -:   20:    unsigned int             length;
        -:   21:};
        -:   22:typedef struct memory_reference memory_reference;
        -:   23:
        -:   24:static int trace_line_number;
        -:   25:
        -:   26:static int access_time;
        -:   27:
        -:   28:
        -:   29:
        -:   30:/* ***************************************************************** */
        -:   31:/*                                                                   */
        -:   32:/*                                                                   */
        -:   33:/* ***************************************************************** */
        -:   34:
        -:   35:/* read on input line */
        -:   36:
 66234017:   37:void read_reference(FILE *trace_file, memory_reference *reference)
        -:   38:{
        -:   39:    int c;
        -:   40:    /* we have the first character; it defined the
        -:   41:       memory access type.  Skip any blanks, get the
        -:   42:       hexadecimal address, skip the comma and get the length */
        -:   43:
        -:   44:    /* skip any leading blanks */
 66234017:   45:    c = skip_blanks(trace_file);
        -:   46:    
 66234017:   47:    memory_address a = 0;
686705618:   48:    while (ishex(c))
        -:   49:        {
554237584:   50:            a = (a << 4) | hexvalue(c);
554237584:   51:            c = getc(trace_file);
        -:   52:        }
 66234017:   53:    if (c != ',')
        -:   54:        {
    #####:   55:            fprintf(stderr, "bad trace file input at line %d: %c\n", trace_line_number, c);
    #####:   56:            exit(-1);
        -:   57:        }
        -:   58:  
        -:   59:    /* skip the comma */
        -:   60:    /* and get the length */
 66234017:   61:    int n = 0;
 66234017:   62:    c = getc(trace_file);    
198716708:   63:    while (isdigit(c))
        -:   64:        {
 66248674:   65:            n = n * 10 + decvalue(c);
 66248674:   66:            c = getc(trace_file);
        -:   67:        }
        -:   68:
        -:   69:    /* skip to end of line */
 66234017:   70:    while ((c != '\n') && (c != EOF)) c = getc(trace_file);
        -:   71:
        -:   72:    /* define reference fields */
 66234017:   73:    reference->address = a;
 66234017:   74:    reference->length = n;
 66234017:   75:}
        -:   76:
        -:   77:
        -:   78:
        -:   79:/* ***************************************************************** */
        -:   80:/*                                                                   */
        -:   81:/*                                                                   */
        -:   82:/* ***************************************************************** */
        -:   83:
        -:   84:
 66234018:   85:int Read_trace_file_line(FILE *trace_file, memory_reference *reference)
        -:   86:{
        -:   87:    int c;
        -:   88:
 66234018:   89:    trace_line_number = 0;
        -:   90:
134234019:   91:    while ((c = getc(trace_file)) != EOF)
        -:   92:        {
        -:   93:            /* start the next line */
 68000000:   94:            trace_line_number += 1;
        -:   95:
        -:   96:            /* skip any leading blanks */
 68000000:   97:            while (isspace(c) && (c != EOF)) c = getc(trace_file);
        -:   98:
        -:   99:            /* what is the character ? */
 68000000:  100:            switch (c)
        -:  101:                {
        -:  102:                case 'I': /* instruction trace */
        -:  103:                    {
 44824735:  104:                        reference->type = MAT_FETCH;
 44824735:  105:                        read_reference(trace_file, reference);
 44824735:  106:                        return('I');
        -:  107:                    }
        -:  108:
        -:  109:                case 'S': /* store */
        -:  110:                    {
  3032458:  111:                        reference->type = MAT_STORE;
  3032458:  112:                        read_reference(trace_file, reference);
  3032458:  113:                        return('S');
        -:  114:                    }
        -:  115:
        -:  116:                case 'L': /* load */
        -:  117:                    {
 18376824:  118:                        reference->type = MAT_LOAD;
 18376824:  119:                        read_reference(trace_file, reference);
 18376824:  120:                        return('L');
        -:  121:                    }
        -:  122:                }
        -:  123:
        -:  124:            /* apparently not a reference line.  There are a bunch
        -:  125:               of other lines that valgrind puts out.  They start
        -:  126:               with  ====, or --, or such.  Skip the entire line. */
        -:  127:            /* skip to end of line */
  1765983:  128:            while ((c != '\n') && (c != EOF)) c = getc(trace_file);
        -:  129:        }
        1:  130:    return(EOF);
        -:  131:}
        -:  132:
        -:  133:
        -:  134:/* ***************************************************************** */
        -:  135:/*                                                                   */
        -:  136:/*                                                                   */
        -:  137:/* ***************************************************************** */
        -:  138:
        -:  139:/* LFU counts the number of times something is used.  To prevent
        -:  140:   a large number from just sitting there, we cause it to decay
        -:  141:   over time.  Every "tick" time units, we shift left one bit,
        -:  142:   so that eventually a count will go to zero if it is not continuing
        -:  143:   to be used. */
        -:  144:
 67378210:  145:void Check_For_Decay(CDS *cds)
        -:  146:{
134756420:  147:    if (cds->replacement_policy != CRP_LFU) return;
        -:  148:
 67378210:  149:    if ((cds->number_of_memory_reference % cds->LFU_Decay_Interval) == 0)
        -:  150:        {
        -:  151:            int i;
      336:  152:            if (debug) fprintf(debug_file, "%s: LFU decay for all LFU counters\n", cds->name);
   344400:  153:            for (i = 0; i < cds->number_of_cache_entries; i++)
        -:  154:                {
   344064:  155:                    cds->c[i].replacement_data = cds->c[i].replacement_data/2;
        -:  156:                }
        -:  157:        }
        -:  158:}
        -:  159:
        -:  160:/* ***************************************************************** */
        -:  161:/*                                                                   */
        -:  162:/*                                                                   */
        -:  163:/* ***************************************************************** */
        -:  164:
   272312:  165:int Replacement_policy(CDS *cds, int first_index, int set_size)
        -:  166:{
        -:  167:    int i;
        -:  168:    int victim;
        -:  169:
   272312:  170:    if (debug) fprintf(debug_file, "%s: look for victim in %d lines starting at %d\n", cds->name,  set_size, first_index);
        -:  171:    /* first look to see if any entry is empty */
  2526634:  172:    for (i = 0; i < set_size; i++)
        -:  173:        {
  2259344:  174:            if (!(cds->c[first_index+i].valid))
        -:  175:                {
     5022:  176:                    victim = first_index+i;
     5022:  177:                    if (debug) fprintf(debug_file, "%s: found empty cache entry at %d\n", cds->name,  victim);
     5022:  178:                    return(victim);
        -:  179:                }
        -:  180:        }
        -:  181:    
   267290:  182:    victim = first_index; /* default victim */
   267290:  183:    switch (cds->replacement_policy)
        -:  184:        {
        -:  185:        case CRP_FIFO:  /* replacement data is the order we were brought in: 1, 2, 3, ... */
        -:  186:                    /* choose the smallest */
        -:  187:
        -:  188:        case CRP_LRU: /* replacement data is a counter where the smallest number is */
        -:  189:                    /* the least recently used, choose smallest */
        -:  190:            
        -:  191:        case CRP_LFU:  /* replacement data is the number of uses, so
        -:  192:                      choose the smallest */
        -:  193:            {
   267290:  194:                int min = cds->c[first_index].replacement_data;
   267290:  195:                if (debug) fprintf(debug_file, "%s: replacement data: [%d]: %d", cds->name, victim, min);
  1725938:  196:                for (i = 1; i < set_size; i++)
        -:  197:                    {
  1458648:  198:                        if (debug) fprintf(debug_file, ", [%d]: %d", first_index+i, cds->c[first_index+i].replacement_data);
  1458648:  199:                        if (cds->c[first_index+i].replacement_data < min)
        -:  200:                            {
    15273:  201:                                victim = first_index+i;
    15273:  202:                                min = cds->c[victim].replacement_data;
        -:  203:                            }
        -:  204:                    }
   267290:  205:                if (debug) fprintf(debug_file, "\n");
        -:  206:            }
   267290:  207:            break;
        -:  208:                              
        -:  209:        case CRP_RANDOM:  
    #####:  210:            victim = first_index + (random() % set_size);
    #####:  211:            break;
        -:  212:
        -:  213:        }
        -:  214:
   267290:  215:    if (debug) fprintf(debug_file, "%s: found victim in entry %d\n", cds->name,  victim);
   267290:  216:    return(victim);
        -:  217:}
        -:  218:
   272312:  219:void Set_Replacement_Policy_Data(CDS *cds, int first_index, int i)
        -:  220:{
   272312:  221:    switch (cds->replacement_policy)
        -:  222:        {
        -:  223:        case CRP_FIFO:  /* replacement data is the order we were brought in: 1, 2, 3, ... */
     2757:  224:            cds->c[first_index+i].replacement_data = cds->number_of_memory_reference;
     2757:  225:            break;
        -:  226:            
        -:  227:        case CRP_LFU:  /* replacement data is a count; starts at zero */
     3460:  228:            cds->c[first_index+i].replacement_data = 0;
     3460:  229:            Check_For_Decay(cds);
        -:  230:            
        -:  231:        case CRP_RANDOM:  
     3460:  232:            break;
        -:  233:
        -:  234:        case CRP_LRU: /* replacement data is based on a time counter that increments
        -:  235:                         read or write */
   266095:  236:            cds->c[first_index+i].replacement_data = access_time;
   266095:  237:            break;
        -:  238:        }
   272312:  239:}
        -:  240:
336618738:  241:void Update_Replacement_Policy_Data(CDS *cds, int first_index, int i)
        -:  242:{
336618738:  243:    switch (cds->replacement_policy)
        -:  244:        {
        -:  245:        case CRP_FIFO:  /* replacement data is the order we were brought in: 1, 2, 3, ... */
 67375453:  246:            break;
        -:  247:            
        -:  248:        case CRP_LFU:  /* replacement data is the count of the number of uses */
 67374750:  249:            cds->c[first_index+i].replacement_data += 1;
 67374750:  250:            Check_For_Decay(cds);
        -:  251:            
        -:  252:        case CRP_RANDOM:  
 67374750:  253:            break;
        -:  254:
        -:  255:        case CRP_LRU:
201868535:  256:            cds->c[first_index+i].replacement_data = access_time;
201868535:  257:            break;
        -:  258:        }
336618738:  259:}
        -:  260:
        -:  261:
        -:  262:/* ***************************************************************** */
        -:  263:/*                                                                   */
        -:  264:/*                                                                   */
        -:  265:/* ***************************************************************** */
        -:  266:
1004952185:  267:memory_address Base_Cache_Address(CDS *cds, memory_address a)
        -:  268:{
        -:  269:    /* find number of low-order bits to mask off to find beginning cache
        -:  270:       line address */
1004952185:  271:    int number_of_low_order_bits = which_power(cds->cache_line_size);
1004952185:  272:    memory_address low_order_mask = mask_of(number_of_low_order_bits);
1004952185:  273:    memory_address cache_address = a & (~low_order_mask);
1004952185:  274:    return(cache_address);
        -:  275:}
        -:  276:
        -:  277:
336891050:  278:void Simulate_Reference_to_Cache_Line(CDS *cds, memory_reference *reference)
        -:  279:{
336891050:  280:    if (debug) fprintf(debug_file, "%s: Reference 0x%08X of length %d\n",
        -:  281:                       cds->name, reference->address, reference->length);
        -:  282:
        -:  283:    //TODO
336891050:  284:    access_time++;
        -:  285:    /* find cache line for this reference */
        -:  286:    /* find number of low-order bits to mask off to find beginning cache
        -:  287:       line address */
        -:  288:    
336891050:  289:    memory_address cache_address = Base_Cache_Address(cds, reference->address);
        -:  290:
        -:  291:    /* shift off low-order offset bits and find bits for 
        -:  292:       indexing into cache table */
        -:  293:    /* the number of sets is the number of cache entries
        -:  294:       divided by the number of ways. */
336891050:  295:    int number_of_low_order_bits = which_power(cds->cache_line_size);
336891050:  296:    int number_of_sets = cds->number_of_cache_entries/cds->number_of_ways;
336891050:  297:    int sets_bits = which_power(number_of_sets);
336891050:  298:    memory_address sets_bits_mask = mask_of(sets_bits);
336891050:  299:    int cache_set_index = (cache_address >> number_of_low_order_bits) & sets_bits_mask;
336891050:  300:    int cache_entry_index = cache_set_index * cds->number_of_ways;
        -:  301:    
        -:  302:    /* index into cache table and search the number of ways to
        -:  303:       try to find cache line. */
        -:  304:    int i;
38977838464:  305:    for (i = 0; i < cds->number_of_ways; i++)
        -:  306:        {
38977566152:  307:            if (cds->c[cache_entry_index+i].valid && (cache_address == cds->c[cache_entry_index+i].tag))
        -:  308:                {
        -:  309:                    /* found it -- record cache hit and exit */
336618738:  310:                    if (debug) fprintf(debug_file, "%s: Found address 0x%08X in cache line %d\n", cds->name, 
        -:  311:                                       reference->address, cache_entry_index+i);
336618738:  312:                    cds->number_cache_hits += 1;
        -:  313:
        -:  314:                    /* update reference specific info */
336618738:  315:                    if (reference->type == MAT_STORE) 
 15128757:  316:                        cds->c[cache_entry_index+i].dirty = TRUE;
336618738:  317:                    Update_Replacement_Policy_Data(cds, cache_entry_index, i);
673509788:  318:                    return;
        -:  319:                }
        -:  320:        }
        -:  321:
        -:  322:    /* Did not find it. */
   272312:  323:    cds->number_cache_misses += 1;    
        -:  324:
        -:  325:    /* Choose a victim from the set */
   272312:  326:    int victim = Replacement_policy(cds, cache_entry_index, cds->number_of_ways);
   272312:  327:    if (debug) fprintf(debug_file, "%s: Pick victim %d to replace\n", cds->name,  victim);
        -:  328:    
        -:  329:    /* evict victim */
        -:  330:
        -:  331:    /* if victim is dirty, must write back to memory first */
   272312:  332:    if (cds->c[victim].dirty)
        -:  333:        {
    67321:  334:            if (debug) fprintf(debug_file, "%s: Write victim 0x%08X to memory\n", cds->name,  cds->c[victim].tag);
    67321:  335:            cds->number_memory_writes += 1;
    67321:  336:            cds->c[victim].dirty = FALSE;
        -:  337:        }
        -:  338:
        -:  339:    /* fill in victim cache line for this new line */
   272312:  340:    cds->c[victim].valid = TRUE;
   272312:  341:    cds->c[victim].tag = cache_address;
   272312:  342:    cds->c[victim].dirty = (reference->type == MAT_STORE);
   272312:  343:    if (debug) fprintf(debug_file, "%s: Read cache line 0x%08X into entry %d\n", cds->name,  cds->c[victim].tag, victim);
        -:  344:
   272312:  345:    Set_Replacement_Policy_Data(cds, cache_entry_index, victim-cache_entry_index);
        -:  346:
        -:  347:    //TODO update global timer
        -:  348:
        -:  349:    /* read cache line from memory into cache table */
   272312:  350:    cds->number_memory_reads += 1;
        -:  351:
   272312:  352:    if (!cds->write_back && (reference->type == MAT_STORE))
        -:  353:        {
        -:  354:            /* If it's not write-back, then it is write-thru.
        -:  355:               For write-thru, if it's a write, we write to memory. */
    #####:  356:            cds->number_memory_writes += 1;
        -:  357:        }
        -:  358:
        -:  359:}
        -:  360:
331170085:  361:void Simulate_Reference_to_Memory(CDS *cds, memory_reference *reference)
        -:  362:{
331170085:  363:    cds->number_of_memory_reference += 1;
331170085:  364:    cds->number_of_type[reference->type] += 1;
        -:  365:
        -:  366:    /* check if the entire reference fits into just one cache line */
331170085:  367:    if (Base_Cache_Address(cds, reference->address) == Base_Cache_Address(cds, reference->address + reference->length -1))
        -:  368:        {
325449120:  369:            Simulate_Reference_to_Cache_Line(cds, reference);
        -:  370:        }
        -:  371:    else
        -:  372:        {
        -:  373:            /* reference spans two cache lines.  Convert it to two
        -:  374:               references: the first cache line, and the second cache line */
        -:  375:            memory_reference reference1;
        -:  376:            memory_reference reference2;
        -:  377:            /* easiest to compute the second part first */
  5720965:  378:            reference2.type = reference->type;
  5720965:  379:            reference2.address = Base_Cache_Address(cds, reference->address + reference->length -1);
  5720965:  380:            reference2.length = reference->address + reference->length - reference2.address;
        -:  381:
  5720965:  382:            reference1.type = reference->type;
  5720965:  383:            reference1.address = reference->address;
  5720965:  384:            reference1.length = reference->length - reference2.length;
        -:  385:
        -:  386:            /* but we do the references first, then second */
  5720965:  387:            Simulate_Reference_to_Cache_Line(cds, &reference1);
  5720965:  388:            Simulate_Reference_to_Cache_Line(cds, &reference2);
        -:  389:        }
331170085:  390:}
        -:  391:
        -:  392:
        -:  393:
        -:  394:
        -:  395:/* ***************************************************************** */
        -:  396:/*                                                                   */
        -:  397:/*                                                                   */
        -:  398:/* ***************************************************************** */
        -:  399:
        -:  400:/* read each input line, and then simulate that reference on each
        -:  401:   cache. */
        -:  402:
        1:  403:void Simulate_Caches(String trace_file_name)
        -:  404:{
        -:  405:    FILE *trace_file;
        -:  406:    memory_reference reference;
        -:  407:
        -:  408:    /* open input file */
        1:  409:    trace_file = fopen(trace_file_name, "r");
        1:  410:    if (trace_file == NULL)
        -:  411:        {
    #####:  412:            fprintf (stderr,"Cannot open trace file %s\n", trace_file_name);
        -:  413:        }
        -:  414:
        1:  415:    Init_caches_for_trace();
        -:  416:
 66234019:  417:    while (Read_trace_file_line(trace_file, &reference) != EOF)
        -:  418:        {
 66234017:  419:            CDS *cds = CDS_root;
463638119:  420:            while (cds != NULL)
        -:  421:                {
331170085:  422:                    Simulate_Reference_to_Memory(cds, &reference);
331170085:  423:                    cds = cds->next;
        -:  424:                }
        -:  425:        }
        1:  426:    fclose(trace_file);
        1:  427:}
