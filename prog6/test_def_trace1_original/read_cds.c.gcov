        -:    0:Source:read_cds.c
        -:    0:Programs:5
        -:    1:
        -:    2:/* ***************************************************************** */
        -:    3:/*                                                                   */
        -:    4:/*                                                                   */
        -:    5:/* ***************************************************************** */
        -:    6:
        -:    7:/* Reading cache descriptions */
        -:    8:
        -:    9:#include "global.h"
        -:   10:#include "utils.h"
        -:   11:#include "cds.h"
        -:   12:#include "caches.h"
        -:   13:
        -:   14:/* ***************************************************************** */
        -:   15:/*                                                                   */
        -:   16:/*                                                                   */
        -:   17:/* ***************************************************************** */
        -:   18:
        -:   19:/* we want to read in a string of some unknown length */
        -:   20:#define MIN_TOKEN_SIZE 128
        -:   21:
        -:   22:struct Token
        -:   23:{
        -:   24:    String string;
        -:   25:    int    length;
        -:   26:};
        -:   27:typedef struct Token Token;
        -:   28:
       10:   29:Token *new_token(void)
        -:   30:{
       10:   31:    Token *t = CAST(Token *, malloc(sizeof(Token)));
       10:   32:    t->length = MIN_TOKEN_SIZE;
       10:   33:    t->string = CAST(String, malloc(t->length));
       10:   34:    return(t);
        -:   35:}
        -:   36:
       10:   37:void delete_token(Token *t)
        -:   38:{
       10:   39:    free(t->string);
       10:   40:    free(t);
       10:   41:}
        -:   42:
      508:   43:void put_char_in_token_at(Token *t, char c, int i)
        -:   44:{
      508:   45:    if (i >= t->length)
        -:   46:        {
        -:   47:            /* need more space */
    #####:   48:            t->length = 2 * t->length;
    #####:   49:            t->string = realloc(t->string, t->length);
    #####:   50:            if (t->string == NULL)
        -:   51:                {
    #####:   52:                    fprintf(stderr, "Hell has frozen over!!!\n");
    #####:   53:                    exit(-1);
        -:   54:                }
        -:   55:        }
      508:   56:    t->string[i] = c;
      508:   57:}
        -:   58:
        -:   59:
       50:   60:void get_token(FILE *CDS_file, Token *t)
        -:   61:{
        -:   62:    int c;
        -:   63:
        -:   64:    /* get the next token in the input stream */
       50:   65:    int i = 0;
        -:   66:
        -:   67:    /* token is empty to start */
       50:   68:    put_char_in_token_at(t, '\0', i);
        -:   69:
        -:   70:    /* skip spacing, look for first character */
       50:   71:    c = skip_blanks(CDS_file);
      100:   72:    if (c == EOF) return;
        -:   73:
      329:   74:    while (isalnum(c) || (c == '_'))
        -:   75:        {
      229:   76:            put_char_in_token_at(t, c, i);
      229:   77:            i = i + 1;
      229:   78:            put_char_in_token_at(t, '\0', i);
      229:   79:            c = getc(CDS_file);
        -:   80:        }
        -:   81:
        -:   82:    /* went one too far, put it back */
       50:   83:    ungetc(c, CDS_file);
        -:   84:}
        -:   85:
        -:   86:
        -:   87:/* ***************************************************************** */
        -:   88:/*                                                                   */
        -:   89:/*                                                                   */
        -:   90:/* ***************************************************************** */
        -:   91:
        -:   92:/* Syntax for Cache Descriptions:  { key=value, key=value, ... } */
        -:   93:/* So, we read a key and a value and define the field of the
        -:   94:   cds defined by the key to have the given value. */
        -:   95:
       30:   96:int get_key_value_pair(FILE *CDS_file, Token *key, Token *value)
        -:   97:{
        -:   98:    int c;
        -:   99:
        -:  100:    /* skip initial spaces */
       30:  101:    c = skip_blanks(CDS_file);
       30:  102:    if (c == EOF) return(EOF);
       30:  103:    if (c == '}') return(EOF);
        -:  104:
        -:  105:    /* went one too far, put it back */
       25:  106:    ungetc(c, CDS_file);
        -:  107:
        -:  108:    /* we want a string for the key */
       25:  109:    get_token(CDS_file, key);
        -:  110:
        -:  111:    /* skip spacing, look for "=" */
       25:  112:    c = skip_blanks(CDS_file);
       25:  113:    if (c == EOF) return(EOF);
       25:  114:    if ((c != '=') && (c != ':') && (c != '-'))
        -:  115:        {
    #####:  116:            fprintf(stderr, "not key=value pair: %s %c\n", key->string, c);
    #####:  117:            return(EOF);
        -:  118:        }
        -:  119:
        -:  120:    /* we want a second string for the value */
       25:  121:    get_token(CDS_file, value);
        -:  122:
        -:  123:    /* skip spacing, look for "," */
       25:  124:    c = skip_blanks(CDS_file);
       25:  125:    if (c == EOF) return(EOF);
       25:  126:    if ((c != ',') && (c != ';') && (c != '}'))
        -:  127:        {
    #####:  128:            fprintf(stderr, "not key=value pair: %s %c\n", key->string, c);
    #####:  129:            return(EOF);
        -:  130:        }
       25:  131:    if (c == '}')
        -:  132:        {
        -:  133:            /* we have the last pair, terminated by a '}'.
        -:  134:               put it back, so that this last pair is processed */
        5:  135:            ungetc(c, CDS_file);
        5:  136:            return(',');
        -:  137:        }
        -:  138:
       20:  139:    return(c);
        -:  140:}
        -:  141:
        -:  142:
       25:  143:void define_key_value_pair(CDS *cds, Token *key, Token *value)
        -:  144:{
       25:  145:    if (debug) fprintf(debug_file, "define %s = %s \n", key->string, value->string);
        -:  146:
        -:  147:    /* look for the name */
       25:  148:    if (strcasestr(key->string, "name") != NULL)
        -:  149:        {
        5:  150:            if (cds->name != NULL) free(cds->name);
        5:  151:            cds->name = remember_string(value->string);
        5:  152:            return;
        -:  153:        }
        -:  154:
        -:  155:    /* look for line size */
       20:  156:    if ((strcasestr(key->string, "line") != NULL) && (strcasestr(key->string, "size") != NULL))
        -:  157:        {
        5:  158:            int n = atoi(value->string);
        5:  159:            cds->cache_line_size = n;
        5:  160:            return;
        -:  161:        }
        -:  162:
        -:  163:    /* look for number of cache entries */
       15:  164:    if (strcasestr(key->string, "entries") != NULL)
        -:  165:        {
        5:  166:            int n = atoi(value->string);
        5:  167:            cds->number_of_cache_entries = n;
        5:  168:            return;
        -:  169:        }
        -:  170:
        -:  171:    /* look for the number of ways */
       10:  172:    if (strcasestr(key->string, "ways") != NULL)
        -:  173:        {
        5:  174:            int n = atoi(value->string);
        5:  175:            cds->number_of_ways = n;
        5:  176:            return;
        -:  177:        }
        -:  178:
        -:  179:    /* look for write-back */
        5:  180:    if ((strcasestr(key->string, "write") != NULL) && (strcasestr(key->string, "back") != NULL))
        -:  181:        {
    #####:  182:            if (strcasestr(value->string, "true") != NULL)
        -:  183:                {
    #####:  184:                    cds->write_back = TRUE;
    #####:  185:                    return;
        -:  186:                }
    #####:  187:            if (strcasestr(value->string, "false") != NULL)
        -:  188:                {
    #####:  189:                    cds->write_back = FALSE;
    #####:  190:                    return;
        -:  191:                }
        -:  192:        }
        -:  193:
        -:  194:    /* look for write-thru */
        5:  195:    if ((strcasestr(key->string, "write") != NULL) && (strcasestr(key->string, "thru") != NULL))
        -:  196:        {
    #####:  197:            if (strcasestr(value->string, "true") != NULL)
        -:  198:                {
    #####:  199:                    cds->write_back = FALSE;
    #####:  200:                    return;
        -:  201:                }
    #####:  202:            if (strcasestr(value->string, "false") != NULL)
        -:  203:                {
    #####:  204:                    cds->write_back = TRUE;
    #####:  205:                    return;
        -:  206:                }
        -:  207:        }
        -:  208:
        -:  209:    /* look for the replacement policy */
        5:  210:    if ((strcasestr(key->string, "policy") != NULL) || (strcasestr(key->string, "replace") != NULL))
        -:  211:        {
        5:  212:            if (strcasestr(value->string, "LFU") != NULL)
        -:  213:                {
        1:  214:                    cds->replacement_policy = CRP_LFU;
        1:  215:                    return;
        -:  216:                }
        4:  217:            if (strcasestr(value->string, "LRU") != NULL)
        -:  218:                {
        3:  219:                    cds->replacement_policy = CRP_LRU;
        3:  220:                    return;
        -:  221:                }
        1:  222:            if (strcasestr(value->string, "random") != NULL)
        -:  223:                {
    #####:  224:                    cds->replacement_policy = CRP_RANDOM;
    #####:  225:                    return;
        -:  226:                }
        1:  227:            if (strcasestr(value->string, "FIFO") != NULL)
        -:  228:                {
        1:  229:                    cds->replacement_policy = CRP_FIFO;
        1:  230:                    return;
        -:  231:                }
        -:  232:        }
        -:  233:
        -:  234:    /* look for line size */
    #####:  235:    if ((strcasestr(key->string, "decay") != NULL) && (strcasestr(key->string, "interval") != NULL))
        -:  236:        {
    #####:  237:            int n = atoi(value->string);
    #####:  238:            cds->LFU_Decay_Interval = n;
    #####:  239:            return;
        -:  240:        }
        -:  241:
    #####:  242:    fprintf(stderr, "don't understand %s = %s\n",key->string, value->string);
        -:  243:} 
        -:  244:
        -:  245:
        6:  246:CDS *Read_CDS_file_entry(FILE *CDS_file)
        -:  247:{
        -:  248:    int c;
        -:  249:
        6:  250:    c = skip_blanks(CDS_file);
       12:  251:    while (c == '#')
        -:  252:        {
    #####:  253:            c = skip_line(CDS_file);
        -:  254:        }
        6:  255:    if (c == EOF) return(NULL);
        -:  256:
        -:  257:    /* Syntax for Cache Descriptions:  { key=value, key=value, ... } */
        -:  258:    /* So, we read a key and a value and define the field of the
        -:  259:       cds defined by the key to have the given value. */
        -:  260:
        5:  261:    if (c != '{')
        -:  262:        {
    #####:  263:            fprintf(stderr, "Cache description should start with {, not %c\n", c);
    #####:  264:            return(NULL);
        -:  265:        }
        -:  266:
        -:  267:    /* starting a new cache description.  Get a structure,
        -:  268:       and fill in default values. */
        5:  269:    CDS *cds = (CDS *)calloc(1,sizeof(CDS));
        5:  270:    cds->name = remember_string("dummy");
        5:  271:    cds->cache_line_size = 64;
        5:  272:    cds->number_of_cache_entries = 1024;
        5:  273:    cds->number_of_ways = 2;
        5:  274:    cds->write_back = TRUE;
        5:  275:    cds->replacement_policy = CRP_FIFO;
        5:  276:    cds->LFU_Decay_Interval = 200000;
        -:  277:
        5:  278:    Token *key = new_token();
        5:  279:    Token *value = new_token();
       35:  280:    while (((c = get_key_value_pair(CDS_file, key, value)) != EOF) && (c != '}'))
        -:  281:        {
       25:  282:            define_key_value_pair(cds, key, value);
        -:  283:        }
        5:  284:    delete_token(key);
        5:  285:    delete_token(value);
        -:  286:
        5:  287:    if (debug) debug_print_cds(cds);
        -:  288:    
        5:  289:    return(cds);
        -:  290:}
        -:  291:
        -:  292:
        -:  293:/* ***************************************************************** */
        -:  294:/*                                                                   */
        -:  295:/*                                                                   */
        -:  296:/* ***************************************************************** */
        -:  297:
        1:  298:void Read_Cache_Descriptions(String CDS_file_name)
        -:  299:{
        -:  300:    FILE *CDS_file;
        -:  301:    CDS *cds;
        -:  302:
        -:  303:    /* open input file */
        1:  304:    CDS_file = fopen(CDS_file_name, "r");
        1:  305:    if (CDS_file == NULL)
        -:  306:        {
    #####:  307:            fprintf (stderr,"Cannot open CDS file %s\n", CDS_file_name);
        -:  308:        }
        7:  309:    while ((cds = Read_CDS_file_entry(CDS_file)) != NULL)
        -:  310:        {
        -:  311:            //TODO speed this up
        -:  312:            /* we use a linked list for all the cache descriptions,
        -:  313:               but we want to keep the list in the same order that
        -:  314:               we read them in.  Bummer. */
        5:  315:            if (CDS_root == NULL)
        -:  316:                {
        1:  317:                    CDS_root = cds;
        -:  318:                }
        -:  319:            else
        -:  320:                {
        4:  321:                    CDS *q = CDS_root;
        4:  322:                    while (q->next != NULL) q = q->next;
        4:  323:                    q->next = cds;
        -:  324:                }
        5:  325:            cds->next = NULL;
        -:  326:        }
        1:  327:    fclose(CDS_file);
        1:  328:}
